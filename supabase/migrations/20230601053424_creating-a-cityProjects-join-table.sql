CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user();


create table "public"."cityProjects" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "listingNames" text,
    "caseNumbers" text,
    "projectStatus" text,
    "projectLocations" text,
    "projectDescriptions" text,
    "recentUpdate" text,
    "typeOfUse" text,
    "applicant" text,
    "applicantPhone" text,
    "applicantEmail" text,
    "plannerName" text,
    "imageUrls" text,
    "city" text,
    "plannerPhone" text,
    "plannerEmail" text,
    "lat" numeric,
    "lng" numeric
);


create table "public"."profiles" (
    "id" uuid not null,
    "updated_at" timestamp with time zone,
    "username" text,
    "full_name" text,
    "avatar_url" text,
    "website" text,
    "email" text,
    "first_name" text,
    "last_name" text,
    "street_address" text,
    "city" text,
    "state" text,
    "postal_code" text,
    "about_section" text,
    "phone_number" text,
    "industry" text,
    "found_us" text,
    "communication_method" text,
    "background" text
);


alter table "public"."profiles" enable row level security;

CREATE UNIQUE INDEX cityprojects_pkey ON public."cityProjects" USING btree (id);

CREATE UNIQUE INDEX profiles_email_key ON public.profiles USING btree (email);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username);

alter table "public"."cityProjects" add constraint "cityprojects_pkey" PRIMARY KEY using index "cityprojects_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."profiles" add constraint "profiles_email_key" UNIQUE using index "profiles_email_key";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_username_key" UNIQUE using index "profiles_username_key";

alter table "public"."profiles" add constraint "username_length" CHECK ((char_length(username) >= 3)) not valid;

alter table "public"."profiles" validate constraint "username_length";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.profiles (id, email, first_name, last_name,  phone_number, industry, city, found_us, communication_method, background)
  values (new.id, new.email, new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'last_name', new.raw_user_meta_data->>'phone_number', new.raw_user_meta_data->>'industry', new.raw_user_meta_data->>'city', new.raw_user_meta_data->>'found_us', new.raw_user_meta_data->>'communication_method', new.raw_user_meta_data->>'background');
  return new;
end;$function$
;

create policy "Public profiles are viewable by everyone."
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Users can insert their own profile."
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Users can update own profile."
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));








